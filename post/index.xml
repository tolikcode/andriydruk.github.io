<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Yet Another Android Developer Blog</title>
    <link>http://andriydruk.github.io/post/</link>
    <description>Recent content in Posts on Yet Another Android Developer Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Code released under the Apache 2.0 license.</copyright>
    <lastBuildDate>Sun, 13 Sep 2015 22:51:10 +0300</lastBuildDate>
    <atom:link href="http://andriydruk.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Wrap Annoying APIs With RxJava</title>
      <link>http://andriydruk.github.io/post/rxdnssd/</link>
      <pubDate>Sun, 13 Sep 2015 22:51:10 +0300</pubDate>
      
      <guid>http://andriydruk.github.io/post/rxdnssd/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://reactivex.io/intro.html&#34;&gt;Reactive Extensions (also known as ReactiveX or Rx)&lt;/a&gt; is a library, that brings &lt;a href=&#34;https://en.wikipedia.org/wiki/Functional_reactive_programming&#34;&gt;FRP&lt;/a&gt; programming paradigm at different platforms. And it&amp;rsquo;s a breath of fresh air for android developers at Java 6 desert. A lot of articles about concept of RxJava and common usage have been already written. That&amp;rsquo;s why I would like to publish my example of usage RxJava in Android just to show how you can wrap java APIs. In this article I will describe process of wrapping Java API of Apple’s DNSSD library (that in my opinion is annoying).&lt;/p&gt;

&lt;p&gt;DNSSD library&amp;rsquo;s public API is a one Singleton that provides static methods that implement basic operation such as searching and advertising. All operations work asynchronously and results will be returned to you in callbacks at background thread. It&amp;rsquo;s a usual java API, what&amp;rsquo;s wrong with it? Let&amp;rsquo;s imagine basic usage scenario of searching services in network:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Browse service&lt;/li&gt;
&lt;li&gt;Resolve service&lt;/li&gt;
&lt;li&gt;Query records&lt;/li&gt;
&lt;li&gt;Update UI&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That&amp;rsquo;s mean that you should start &amp;lsquo;browse&amp;rsquo; operation with BrowseCallback, in this callback start &amp;lsquo;resolve&amp;rsquo; with ResolveCallback and than inside this callback you start &amp;lsquo;query records&amp;rsquo; with QueryRecordsCallback and than send message to MainThread and here you update your UI. It turns to &amp;lsquo;callback hell&amp;rsquo;. Real problems start when user leaves your app before you get result from this chain and you should unsubscribe all listeners and cancel all operations.&lt;/p&gt;

&lt;p&gt;Ok, let&amp;rsquo;s wrap this API with RxJava.&lt;/p&gt;

&lt;h2 id=&#34;intro:167ce4eccbd4d3a1fceeff7ec1945355&#34;&gt;&lt;strong&gt;Intro&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;If you don’t familiar with RxJava, I highly recommend you start from official documentation. In this article I won’t explain RxJava operators, only example of usage.&lt;/p&gt;

&lt;p&gt;Ok, firstly, lets look at DNSSD Apple API:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;abstract public class DNSSD{
    public static DNSSDService  browse( int flags, int ifIndex, String regType, 
        String domain, BrowseListener listener) throws DNSSDException;

    public static DNSSDService  resolve( int flags, int ifIndex, String serviceName, 
        String regType, String domain, ResolveListener listener) throws DNSSDException;

    public static DNSSDService  queryRecord( int flags, int ifIndex, String serviceName, 
        int rrtype, int rrclass, QueryListener listener) throws DNSSDException;
}

public interface BrowseListener extends BaseListener
{
    /** Called to report discovered services.&amp;lt;P&amp;gt; */
    void    serviceFound(DNSSDService browser, int flags, int ifIndex,
                         String serviceName, String regType, String domain);

    /** Called to report services which have been deregistered.&amp;lt;P&amp;gt; */
    void    serviceLost(DNSSDService browser, int flags, int ifIndex,
                        String serviceName, String regType, String domain);


}

public interface ResolveListener extends BaseListener
{
    /** Called when a service has been resolved.&amp;lt;P&amp;gt; */
    void    serviceResolved(DNSSDService resolver, int flags, int ifIndex, String fullName,
                            String hostName, int port, TXTRecord txtRecord);
}

public interface QueryListener extends BaseListener
{
    /** Called when a record query has been completed. Inspect flags 
        parameter to determine nature of query event.&amp;lt;P&amp;gt; */
    void    queryAnswered(DNSSDService query, int flags, int ifIndex, String fullName,
                          int rrtype, int rrclass, byte[] rdata, int ttl);
}

public interface BaseListener
{
    /** Called to report DNSSD operation failures.&amp;lt;P&amp;gt; */
    void    operationFailed(DNSSDService service, int errorCode);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Every method returns DNSSDService object, that actually is analog of &lt;a href=&#34;http://reactivex.io/RxJava/javadoc/rx/Subscription.html&#34;&gt;Subscription&lt;/a&gt; object from RxJava.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface DNSSDService
{
    /**
    Halt the active operation and free resources associated with the DNSSDService.&amp;lt;P&amp;gt;

    Any services or records registered with this DNSSDService will be deregistered. Any
    Browse, Resolve, or Query operations associated with this reference will be terminated.&amp;lt;P&amp;gt;
    */
    void stop();
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I presented every operation (static method from DNSSD) as a RxJava Observable:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface class RxDNSSDService {
     Observable&amp;lt;T&amp;gt; getObservable(Context context);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Actually implementation of getObservable method can be common for all operations. Let&amp;rsquo;s transform interface to abstract class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;abstract static class RxDNSSDService&amp;lt;T&amp;gt; {

    DNSSDService mService;

    protected abstract DNSSDService getService(Subscriber&amp;lt;? super T&amp;gt; subscriber) 
        throws DNSSDException;

    protected Observable&amp;lt;T&amp;gt; getObservable(final Context context){
        return Observable.create(new Observable.OnSubscribe&amp;lt;T&amp;gt;() {

            @Override
            public void call(Subscriber&amp;lt;? super T&amp;gt; subscriber) {
                if (!subscriber.isUnsubscribed()) {
                    context.getSystemService(Context.NSD_SERVICE);
                    try {
                        mService = getService(subscriber);
                    } catch (DNSSDException e) {
                        e.printStackTrace();
                        subscriber.onError(e);
                    }
                }
            }
        }).doOnUnsubscribe(() -&amp;gt; {
            if (mService != null) {
                mService.stop();
                mService = null;
            }
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now method getObservable returns new Observalbe. Inside OnSubsribe callback I will check if subsriber is subscribed at this moment and call original DNSSD API.  Also I added &lt;a href=&#34;http://reactivex.io/documentation/operators/do.html&#34;&gt;doOnUnsubscribe&lt;/a&gt; operator where I will stop DNSSDService from Apple&amp;rsquo;s library.&lt;/p&gt;

&lt;p&gt;Before implementing classes extended RxDNSSDService I created BonjourService POJO class. Main idea is create chain of observables that will be operate with this class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class BonjourService {

    public final int flags;
    public final int ifIndex;
    public final String serviceName;
    public final String regType;
    public final String domain;

    public BonjourService(int flags, int ifIndex, String serviceName, String regType, 
    	String domain) {
        this.flags = flags;
        this.ifIndex = ifIndex;
        this.serviceName = serviceName;
        this.regType = regType;
        this.domain = domain;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;browse:167ce4eccbd4d3a1fceeff7ec1945355&#34;&gt;&lt;strong&gt;Browse&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Ok, first operation I created is &amp;lsquo;browse&amp;rsquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static Observable&amp;lt;BonjourService&amp;gt; browse(final String regType, final String domain) {
    return new RxDNSSDService&amp;lt;BonjourService&amp;gt; (){
        @Override
        protected DNSSDService getService(Subscriber&amp;lt;? super BonjourService&amp;gt; subscriber) 
                throws DNSSDException {
            return DNSSD.browse(0, DNSSD.ALL_INTERFACES, regType, domain,
                    new RxDNSSD.BrowseListener(subscriber));
        }
    }.getObservable(INSTANCE.mContext);
}

private static class BrowseListener implements com.apple.dnssd.BrowseListener{
    private Subscriber&amp;lt;? super BonjourService&amp;gt; mSubscriber;

    private BrowseListener(Subscriber&amp;lt;? super BonjourService&amp;gt; subscriber){
        mSubscriber = subscriber;
    }

    @Override
    public void serviceFound(DNSSDService browser, int flags, int ifIndex, 
            String serviceName, String regType, String domain) {
        if (mSubscriber.isUnsubscribed()){
            return;
        }
        BonjourService service = new BonjourService(flags, ifIndex, serviceName, 
            regType, domain);
        mSubscriber.onNext(service);
    }

    @Override
    public void serviceLost(DNSSDService browser, int flags, int ifIndex, 
            String serviceName, String regType, String domain) {
        //Not implemented yet
    }

    @Override
    public void operationFailed(DNSSDService service, int errorCode) {
        if (mSubscriber.isUnsubscribed()){
            return;
        }
        mSubscriber.onError(new RuntimeException(&amp;quot;DNSSD browse error: &amp;quot; + errorCode));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;lsquo;browse&amp;rsquo; is endless operation that&amp;rsquo;s why it never calls onComplete method of Subscriber. Every time when DNSSD library calls serviceFound callback I emit new BonjourService object. But now I don&amp;rsquo;t process serviceLost callback. In RxJava Observable presents line of event that happend at some time sequence. That&amp;rsquo;s why I have to create some additional class (for example BrowseAnswer) that contains BonjourService and boolean flag. But it will destroy our idea about chain of observable with one type - BonjourService. Actually BonjourService already has a flag and I will use it to mark BonjourService as deleted. According to DNSSD documentation Apple uses next masks for flags:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**	Flag indicates to a {@link BrowseListener} that another result is
	queued.  Applications should not update their UI to display browse
	results if the MORE_COMING flag is set; they will be called at least once
	more with the flag clear.
*/
public static final int		MORE_COMING = ( 1 &amp;lt;&amp;lt; 0 );

/**	If flag is set in a {@link DomainListener} callback, indicates that the 
	result is the default domain. 
*/
public static final int		DEFAULT = ( 1 &amp;lt;&amp;lt; 2 );

/**	If flag is set, a name conflict will trigger an exception when registering 
	non-shared records.&amp;lt;P&amp;gt; A name must be explicitly specified when 
	registering a service if this bit is set (i.e. the default name may 
	not not be used).
 */
public static final int		NO_AUTO_RENAME = ( 1 &amp;lt;&amp;lt; 3 );

/**	If flag is set, allow multiple records with this name on 
	the network (e.g. PTR records)
	when registering individual records on a {@link DNSSDRegistration}.
*/
public static final int		SHARED = ( 1 &amp;lt;&amp;lt; 4 );

/**	If flag is set, records with this name must be unique on 
	the network (e.g. SRV records). 
*/
public static final int		UNIQUE = ( 1 &amp;lt;&amp;lt; 5 );

/**	Set flag when calling enumerateDomains() to restrict results to domains 
	recommended for browsing. 
*/
public static final int		BROWSE_DOMAINS = ( 1 &amp;lt;&amp;lt; 6 );

/**	Set flag when calling enumerateDomains() to restrict results to domains 
	recommended for registration. 
*/
public static final int		REGISTRATION_DOMAINS = ( 1 &amp;lt;&amp;lt; 7 );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Despite of fact that not all of this flags uses with browse operation, we will create a new mask (1 &amp;lt;&amp;lt; 8) for our DELETED flag. If you not familiar with bit shifts, this operator make shift for binary number to N position. In case above it&amp;rsquo;s number 256. After adding new mask &amp;lsquo;serviceLost&amp;rsquo; method looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public void serviceLost(DNSSDService browser, int flags, int ifIndex, String serviceName, 
        String regType, String domain) {
    if (mSubscriber.isUnsubscribed()){
        return;
    }
    BonjourService service = new BonjourService(flags | BonjourService.DELETED, ifIndex, 
        serviceName, regType, domain);
    mSubscriber.onNext(service);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now look to usage of my browse method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;mSubscription = RxDNSSD.browse(mReqType, mDomain)
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(bonjourService -&amp;gt; {
        if ((bonjourService.flags &amp;amp; BonjourService.DELETED) != BonjourService.DELETED) {
            mAdapter.add(bonjourService);
        } else {
            mAdapter.remove(bonjourService);
        }
        mAdapter.notifyDataSetChanged();
    }, throwable -&amp;gt; {
        Log.e(&amp;quot;DNSSD&amp;quot;, &amp;quot;Error: &amp;quot;, throwable);
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I don&amp;rsquo;t use subscribeOn, because DNSSD will create own thread and it&amp;rsquo;s not a necessary to call all DNSSD API methods from background thread. But observeOn I use always, because all callbacks from DNSSD API will called from background thread.&lt;/p&gt;

&lt;h2 id=&#34;resolve:167ce4eccbd4d3a1fceeff7ec1945355&#34;&gt;&lt;strong&gt;Resolve&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Next operation is DNSSD.resolve(). I use this operation to resolve a service name to a target host name, port number, and txt record.
Unlike browse() operation this one will return Trasnformation, that transform  Observable of BonjourService to Observable of resolved BonourService.&lt;/p&gt;

&lt;p&gt;First of all I applied a &lt;a href=&#34;http://reactivex.io/documentation/operators/flatmap.html&#34;&gt;flatMap&lt;/a&gt; to income Observalbe. Than in map&amp;rsquo;s function I check if BonjourService contains DELETED flag, then emit this Observable (maybe information about this BonjourService will be usefull for Subsriber).
In other case I emit Observable from RxDNSSDService that will query record from DNSSD API.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static Observable.Transformer&amp;lt;BonjourService, BonjourService&amp;gt; resolve() {
    return observable -&amp;gt; observable.flatMap(bs -&amp;gt; {
        if ((bs.flags &amp;amp; BonjourService.DELETED) == BonjourService.DELETED) {
            return Observable.just(bs);
        }
        return new RxDNSSDService&amp;lt;BonjourService&amp;gt;() {
            @Override
            protected DNSSDService getService(Subscriber&amp;lt;? super BonjourService&amp;gt; subscriber) 
                    throws DNSSDException {
                return DNSSD.resolve(bs.flags, bs.ifIndex, bs.serviceName, bs.regType, 
                    bs.domain, new ResolveListener(subscriber, bs));
            }
        }.getObservable(INSTANCE.mContext);
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If operation finish successfully, I will put resolved address to BonjourService&amp;rsquo;s map and send it to Subscriber. Unlike browse() operation this one is not endless, that&amp;rsquo;s why after emitting Bonjour Service I call onComplete. In case of cathing error, I forward error to Subscriber.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static class ResolveListener implements com.apple.dnssd.ResolveListener{
    private Subscriber&amp;lt;? super BonjourService&amp;gt; mSubscriber;
    private BonjourService mBonjourService;

    private ResolveListener(Subscriber&amp;lt;? super BonjourService&amp;gt; subscriber, 
            BonjourService service){
        mSubscriber = subscriber;
        mBonjourService = service;
    }

    @Override
    public void serviceResolved(DNSSDService resolver, int flags, int ifIndex, 
            String fullName, String hostName, int port, TXTRecord txtRecord) {
        if (mSubscriber.isUnsubscribed()){
            return;
        }
        mBonjourService.port = port;
        mBonjourService.hostname = hostName;
        mBonjourService.dnsRecords.clear();
        mBonjourService.dnsRecords.putAll(parseTXTRecords(txtRecord));
        mBonjourService.timestamp = System.currentTimeMillis();
        mSubscriber.onNext(mBonjourService);
        mSubscriber.onCompleted();
        resolver.stop();
    }

    @Override
    public void operationFailed(DNSSDService service, int errorCode) {
        if (mSubscriber.isUnsubscribed()){
            return;
        }
        mSubscriber.onError(new RuntimeException(&amp;quot;DNSSD resolve error: &amp;quot; + errorCode));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example of usage:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;mResolveSubscription = Observable.just(mService)
        .compose(RxDNSSD.resolve())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe(bonjourService -&amp;gt; {
            if ((bonjourService.flags &amp;amp; BonjourService.DELETED) == BonjourService.DELETED) {
                return;
            }
            updateUI(bonjourService, true);
        }, throwable -&amp;gt; {
            Log.e(&amp;quot;DNSSD&amp;quot;, &amp;quot;Error: &amp;quot;, throwable);
        });
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;query-records:167ce4eccbd4d3a1fceeff7ec1945355&#34;&gt;&lt;strong&gt;Query Records&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;DNSSD.queryRecords() we use to query for an arbitrary DNS record. This operation is very similar to previos.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static Observable.Transformer&amp;lt;BonjourService, BonjourService&amp;gt; queryRecords() {
    return observable -&amp;gt; observable.flatMap(bs -&amp;gt; {
        if ((bs.flags &amp;amp; BonjourService.DELETED) == BonjourService.DELETED) {
            return Observable.just(bs);
        }
        return new RxDNSSDService&amp;lt;BonjourService&amp;gt;() {
            @Override
            protected DNSSDService getService(Subscriber&amp;lt;? super BonjourService&amp;gt; subscriber) 
                    throws DNSSDException {
                return DNSSD.queryRecord(0, bs.ifIndex, bs.hostname, 1 , 1,
                        new QueryListener(subscriber, bs));
            }
        }.getObservable(INSTANCE.mContext);
    });
}

private static class QueryListener implements com.apple.dnssd.QueryListener{
    private Subscriber&amp;lt;? super BonjourService&amp;gt; mSubscriber;
    private BonjourService mBonjourService;

    private QueryListener(Subscriber&amp;lt;? super BonjourService&amp;gt; subscriber, 
            BonjourService bonjourService){
        mSubscriber = subscriber;
        mBonjourService = bonjourService;
    }

    @Override
    public void queryAnswered(DNSSDService query, int flags, int ifIndex, 
            String fullName, int rrtype, int rrclass, byte[] rdata, int ttl) {
        if (mSubscriber.isUnsubscribed()){
            return;
        }
        try {
            InetAddress address = InetAddress.getByAddress(rdata);
            mBonjourService.dnsRecords.put(BonjourService.DNS_RECORD_KEY_ADDRESS, 
                address.getHostAddress());
            mSubscriber.onNext(mBonjourService);
            mSubscriber.onCompleted();
        } catch (Exception e) {
            mSubscriber.onError(e);
        } finally {
            query.stop();
        }
    }
    @Override
    public void operationFailed(DNSSDService service, int errorCode) {
        if (mSubscriber.isUnsubscribed()){
            return;
        }
        mSubscriber.onError(new RuntimeException(&amp;quot;DNSSD queryRecord error: &amp;quot; + errorCode));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If operation finish sucessfully, I put resolved address to BonjourService map and emmit this object.&lt;/p&gt;

&lt;p&gt;Example of usage:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;mResolveSubscription = Observable.just(mService)
        .compose(RxDNSSD.resolve())
        .compose(RxDNSSD.queryRecords())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe(bonjourService -&amp;gt; {
            if ((bonjourService.flags &amp;amp; BonjourService.DELETED) == BonjourService.DELETED) {
                return;
            }
            updateUI(bonjourService, true);
        }, throwable -&amp;gt; {
            Log.e(&amp;quot;DNSSD&amp;quot;, &amp;quot;Error: &amp;quot;, throwable);
        });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Creating of rx chains is very usefull. Because now you shouldn&amp;rsquo;t care about canceling all operations and removing listeners. The only one thing you should do inside your onPause||onStop||onDestroy methods is mSubscription.cancel().
Sample of using described wrapper (I called it RxDNSSD) you can find in my project &lt;a href=&#34;https://github.com/andriydruk/BonjourBrowser&#34;&gt;Bonjour Browser&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s all. Happy wrapping annoying APIs.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bonjour in Android applications</title>
      <link>http://andriydruk.github.io/post/mdnsresponder/</link>
      <pubDate>Sat, 05 Sep 2015 14:14:19 +0300</pubDate>
      
      <guid>http://andriydruk.github.io/post/mdnsresponder/</guid>
      <description>&lt;p&gt;&lt;strong&gt;What is Bonjour?&lt;/strong&gt;
Wiki definition of Bonjour is&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Bonjour is Apple&amp;rsquo;s implementation of Zero-configuration networking (Zeroconf), a group of technologies that includes service discovery, address assignment, and hostname resolution. Bonjour locates devices such as printers, other computers, and the services that those devices offer on a local network using multicast Domain Name System (mDNS) service records.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Apple definition is&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Bonjour, also known as zero-configuration networking, enables automatic discovery of devices and services on a local network using industry standard IP protocols. Bonjour makes it easy to discover, publish, and resolve network services with a sophisticated, yet easy-to-use, programming interface that is accessible from Cocoa, Ruby, Python, and other languages.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In other words, Bonjour is a software component that is used for other devices discovery (PC, Mac, smartphones, printers, etc) in a network via all available interfaces. A Bonjour term for a device on a network is &amp;ldquo;service&amp;rdquo;. Any application in your operating system can register a service and assign it to an opened port on your computer (actually Bonjour does not guarantee that a port in service&amp;rsquo;s metadata is opened and connected to the app that registered this service). All services are registered in some domain (that&amp;rsquo;s a mandatory parameter for all services and you can find domain naming conventions &lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/NetServices/Articles/domainnames.html&#34;&gt;here&lt;/a&gt;). Also applications can discover all available services at any domain. You should understand that Bonjour is only a technology for services discovery, all connection you have to do by yourself anyway.&lt;/p&gt;

&lt;p&gt;You can find more information about Bonjour in &lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/NetServices/Introduction.html&#34;&gt;official documentation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What about Android? Can we use this powerful technology in our Android projects?&lt;/strong&gt; Yes. Google uses this technology in lots of their projects. For example: you try to connect to Chromecast in your living room - it&amp;rsquo;s Bonjour. You are playing games with your friends via wifi - it&amp;rsquo;s Bonjour. You print documents via wifi on your printer - Bonjour is here again.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Is there a standard Android API for it?&lt;/strong&gt; Yes. Google provides &lt;a href=&#34;http://developer.android.com/training/connect-devices-wirelessly/nsd.html&#34;&gt;Network Service Discovery API&lt;/a&gt; that uses the same technology Apple uses in Mac OS X and iOS (Oh, I&amp;rsquo;ve forgotten to tell you that Bonjour is open-source). This API is available starting from API level 16 (Android 4.1) and works well in general, though it doesn&amp;rsquo;t cover all Bonjour functionality. One of the most important parts of Bonjour API is ability to share some metadata about a service, also known as TXT records.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s what &lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/NetServices/Articles/NetServicesArchitecture.html&#34;&gt;official documentation&lt;/a&gt; says about it:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The TXT record has the same name as the corresponding SRV record, and can contain a small amount of additional information about the service instance, typically no more than 100–200 bytes at most. This record may also be empty. For example, a network game could advertise the name of the map being used in a multiplayer game, and a chat program could advertise the availability of the user (for example, idle, away, or available). If you need to transmit larger amounts of data, the host should establish a connection with the client and send the data directly.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This feature can be very useful and I don&amp;rsquo;t understand why it isn&amp;rsquo;t available in the official SDK. There is no technical reason for this.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Are there any other options?&lt;/strong&gt; Yes, another option for Android developers is &lt;a href=&#34;http://jmdns.sourceforge.net&#34;&gt;jmDNS&lt;/a&gt; library. It&amp;rsquo;s an open-source library written in Java 1.6 (this matters for Android developers) and it&amp;rsquo;s compatible with Apple&amp;rsquo;s Bonjour. You can use it at any Android API level and this library supports TXT records. Yet I do have some issues with jmDNS (I got a few crashes inside jmDNS from Crashlytcics, and I have no idea how I can fix it) and it works pretty slow.&lt;/p&gt;

&lt;p&gt;Also Google (not Android open source project) has introduced a new cross-platform library &lt;a href=&#34;https://developers.google.com/nearby/&#34;&gt;Google Nearby API&lt;/a&gt;. Its API consists of two conceptually different APIs: Nearby Messages API and Nearby Connections API. Message API can be used for services discovering via all available interfaces (Wifi, Wifi-direct, Bluetooth 2.0 and LE) and connecting two or more devices via Internet. Actually this is a very interesting idea in time of fast mobile internet (I might write more about it in another article). And Connections API can be used for discovering and connecting via wifi interface. Actually it&amp;rsquo;s a really good solution. You don&amp;rsquo;t need to bother with sockets, ports, discovering, connections and multithreading. All these have already been done for you. But this solution works only with Android and iOS, and it&amp;rsquo;s not open-source (that&amp;rsquo;s why I emphasize that it&amp;rsquo;s a Google project). If you want to discover some services from another system or your app works with other libraries (for example: printers or vnc servers) you should look for other options.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Do you know any other options?&lt;/strong&gt; Yes, and that&amp;rsquo;s why I&amp;rsquo;m writing this article. I have good news for you: you can just get Apple&amp;rsquo;s implementation of Bonjour and use it in your Android project.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WHAAAAAAT? Apple&amp;rsquo;s libraries in Android project?&lt;/strong&gt; Yes, it&amp;rsquo;s called mDnsResponder and it has been written in C many years ago (actually Apple has bought it). Here is its architecture overview from &lt;a href=&#34;http://opensource.apple.com/source/mDNSResponder/mDNSResponder-66.3/README.txt?txt&#34;&gt;documentation&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A typical mDNS program contains three components:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;http://andriydruk.github.io/img/Screen Shot 2015-09-05 at 23.21.23.png&#34; alt=&#34;Alt text&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The &amp;ldquo;mDNS Core&amp;rdquo; layer is absolutely identical for all applications and
all Operating Systems.&lt;/p&gt;

&lt;p&gt;The &amp;ldquo;Platform Support&amp;rdquo; layer provides the necessary supporting routines
that are specific to each platform &amp;ndash; what routine do you call to send
a UDP packet, what routine do you call to join multicast group, etc.&lt;/p&gt;

&lt;p&gt;The &amp;ldquo;Application&amp;rdquo; layer does whatever that particular application wants
to do. It calls routines provided by the &amp;ldquo;mDNS Core&amp;rdquo; layer to perform
the functions it needs &amp;ndash;
 * advertise services,
 * browse for named instances of a particular type of service
 * resolve a named instance to a specific IP address and port number,
 * etc.
The &amp;ldquo;mDNS Core&amp;rdquo; layer in turn calls through to the &amp;ldquo;Platform Support&amp;rdquo;
layer to send and receive the multicast UDP packets to do the actual work.&lt;/p&gt;

&lt;p&gt;Apple currently provides &amp;ldquo;Platform Support&amp;rdquo; layers for Mac OS 9, Mac OS X,
Microsoft Windows, VxWorks, and for POSIX platforms like Linux, Solaris,
FreeBSD, etc.&lt;/p&gt;

&lt;p&gt;Note: Developers writing applications for OS X do not need to incorporate
this code into their applications, since OS X provides a system service to
handle this for them. If every application developer were to link-in the
mDNSResponder code into their application, then we would end up with a
situation like the picture below:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;http://andriydruk.github.io/img/Screen Shot 2015-09-05 at 23.21.31.png&#34; alt=&#34;Alt text&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This would not be very efficient. Each separate application would be sending
their own separate multicast UDP packets and maintaining their own list of
answers. Because of this, OS X provides a common system service which client
software should access through the &amp;ldquo;/usr/include/dns_sd.h&amp;rdquo; APIs.&lt;/p&gt;

&lt;p&gt;The situation on OS X looks more like the picture below:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;http://andriydruk.github.io/img/Screen Shot 2015-09-05 at 23.21.39.png&#34; alt=&#34;Alt text&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Applications on OS X make calls to the single mDNSResponder daemon
which implements the mDNS and DNS-SD protocols.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In fact Android uses the same solution in one system daemon and lots of applications. The daemon is available for developers since API 16 (Android 4.1) and you can connect to it from a native level via dns-sd.h.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;But I don&amp;rsquo;t know C/C++! Do you have any Java wrapper for it?&lt;/strong&gt; No, but Apple does. Let&amp;rsquo;s compile it together. First of all you need to compile mDnsResponder native client. You can find its source code &lt;a href=&#34;https://android.googlesource.com/platform/external/mdnsresponder/&#34;&gt;here&lt;/a&gt;. It&amp;rsquo;s a part of Android open-source project and it&amp;rsquo;s updated from time to time, but it is completely independent library that works through POSIX API. I believe, that you can use any version of it with any version of Android. Also you should add JNI bridge to this native source code. Just go to dns-sd.h file and look for version of mDNSResponer. In my case it is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* _DNS_SD_H contains the mDNSResponder version number for this header file, formatted as follows:
 *   Major part of the build number * 10000 +
 *   minor part of the build number *   100
 * For example, Mac OS X 10.4.9 has mDNSResponder-108.4, which would be represented as
 * version 1080400. This allows C code to do simple greater-than and less-than comparisons:
 * e.g. an application that requires the DNSServiceGetProperty() call (new in mDNSResponder-126) can check:
 *
 *   #if _DNS_SD_H+0 &amp;gt;= 1260000
 *   ... some C code that calls DNSServiceGetProperty() ...
 *   #endif
 *
 * The version defined in this header file symbol allows for compile-time
 * checking, so that C code building with earlier versions of the header file
 * can avoid compile errors trying to use functions that aren&#39;t even defined
 * in those earlier versions. Similar checks may also be performed at run-time:
 *  =&amp;gt; weak linking -- to avoid link failures if run with an earlier
 *     version of the library that&#39;s missing some desired symbol, or
 *  =&amp;gt; DNSServiceGetProperty(DaemonVersion) -- to verify whether the running daemon
 *     (&amp;quot;system service&amp;quot; on Windows) meets some required minimum functionality level.
 */

#ifndef _DNS_SD_H
#define _DNS_SD_H 3201080
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It means that mDNSResponder version is 320.10.80. Now go to &lt;a href=&#34;http://opensource.apple.com/tarballs/mDNSResponder/&#34;&gt;Apple Open Source&lt;/a&gt; site and find this version. Unzip downloaded archive and find folder /mDNSShared/Java/. Copy JNISupport.c file to your jni folder and all *.java files to your scr folder. Then add JNISupport to Android.mk file, in my case:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;LOCAL_SRC_FILES :=  mDNSShared/dnssd_clientlib.c  \
                    mDNSShared/dnssd_clientstub.c \
                    mDNSShared/dnssd_ipc.c \
                    mDNSShared/JNISupport.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s all. Compile the native code with &amp;lsquo;ndk-build&amp;rsquo; command and then build your Android project.&lt;/p&gt;

&lt;p&gt;And one more thing: Android can stop the daemon to save battery or for some other reason(if it&amp;rsquo;s not used for example). That&amp;rsquo;s why you should call next method before working with any code from com.apple.dnssd.*.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;context.getSystemService(Context.NSD_SERVICE);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Otherwise, mDNSResponder will throw a checked exception &amp;ldquo;DNSD-SD Daemon not available&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Do you have any examples?&lt;/strong&gt; Yep, you can find an example of mDNSResponder usage (containing compiled native libraries with  the latest ndk version for all architectures) in my project Bonjour Browser, all code is available on &lt;a href=&#34;https://github.com/andriydruk/BonjourBrowser&#34;&gt;GitHub&lt;/a&gt;. You can also see it in action in &lt;a href=&#34;https://play.google.com/store/apps/details?id=com.druk.bonjour.browser&amp;amp;hl=uk&#34;&gt;Google Play.&lt;/a&gt; It works really fast!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Деобфускация трассировок стека</title>
      <link>http://andriydruk.github.io/post/android-deobfuscation/</link>
      <pubDate>Tue, 04 Aug 2015 22:40:49 +0300</pubDate>
      
      <guid>http://andriydruk.github.io/post/android-deobfuscation/</guid>
      <description>&lt;p&gt;Одной из самых плохо описанных областей в Android разработке есть руководства по использованию инструментов разработчика. Поэтому я решил описать их в серии небольших статей. В этой статья я хочу рассказать о том какие инструменты предоставляет SDK для работы с трассировками стеков (stacktraces), полученых из выпущенных сборок.&lt;/p&gt;

&lt;p&gt;Одной из проблем поддержки выпущенных Android приложений является деобфускация или retrace трассировок стеков полученнных из обфусцированных сборок. Для того чтобы разобраться в том как деобфусцировать трассировки стеков, нужно понять как работает обфускация. Стандратным способом обфускации в Android есть использования такого инструмента как ProGuard. Вот что о нем говорит &lt;a href=&#34;http://developer.android.com/tools/help/proguard.html#decoding&#34;&gt;официальная документация&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The ProGuard tool shrinks, optimizes, and obfuscates your code by removing unused code and renaming classes, fields, and methods with semantically obscure names.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ну чтож звучит неплохо, попробуем на практике. Начнем с самого простого: создадим новый проект с помощью Android Studio и включим обфускацию для отладочных сборок:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;buildTypes {
    debug {
        minifyEnabled true
        proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
    }
    release {
        minifyEnabled false
        proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Выкинем новое исключение в методе onCreate класса MainActivity&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    throw new RuntimeException(&amp;quot;Stack deobfuscation example exception&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;После запуска получим трассировку стека похожую на следующую&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Caused by: java.lang.RuntimeException: Stack deobfuscation example exception
    at com.druk.myapplication.MainActivity.onCreate(Unknown Source)
    at android.app.Activity.performCreate(Activity.java:6162)
    at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1107)
    at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2370)
    at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2477)
    at android.app.ActivityThread.-wrap11(ActivityThread.java)
    at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1345)
    at android.os.Handler.dispatchMessage(Handler.java:102)
    at android.os.Looper.loop(Looper.java:148)
    at android.app.ActivityThread.main(ActivityThread.java:5415)
    at java.lang.reflect.Method.invoke(Native Method)
    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:725)
    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:615)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Почему же после обфускации MainActivity осталась MainActivity? Дело в том что помимо конфигурационого файла proguard-rules.pro в нашем каталоге (который в сгенерированном примере долежен быть пустым), ProGuard использует стандратные правила обфускации Android проектов из SDK, которые и ослабляют обфускацию наследников Activity. В документации Proguard можно найти следующие правила для Android проектов:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;-keep public class * extends android.app.Activity
-keep public class * extends android.app.Application
-keep public class * extends android.app.Service
-keep public class * extends android.content.BroadcastReceiver
-keep public class * extends android.content.ContentProvider
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Тоесть по умолчанию ProGuard оставляет все имена классов, которые являются наследниками android.app.Activity. Продолжим наш эксперемент: создадим внутренни статический класс, который поможет нам вызвать аварийную ситуацию в нашем приложении&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static class CrashHelper{

    public static void crash(){
        throw new RuntimeException(&amp;quot;Stack deobfuscation example exception&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Вызвав статический метод crash в onCreate мы получим следующую трассировку стека:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Caused by: java.lang.RuntimeException: Stack deobfuscation example exception
     at com.druk.myapplication.a.b(Unknown Source)
     at com.druk.myapplication.a.a(Unknown Source)
     at com.druk.myapplication.MainActivity.onCreate(Unknown Source)
     at android.app.Activity.performCreate(Activity.java:6162)
     at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1107)
     at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2370)
     at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2477)
     at android.app.ActivityThread.-wrap11(ActivityThread.java)
     at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1345)
     at android.os.Handler.dispatchMessage(Handler.java:102)
     at android.os.Looper.loop(Looper.java:148)
     at android.app.ActivityThread.main(ActivityThread.java:5415)
     at java.lang.reflect.Method.invoke(Native Method)
     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:725)
     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:615)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Похоже это то что мы хотели получить. У некоторого мифического класса &amp;lsquo;а&amp;rsquo; был вызван метод &amp;lsquo;a&amp;rsquo;, в теле которого был вызван метод &amp;lsquo;b&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;Для деобфускации нам нужен файл mapping.txt из нашего build каталога. В моем случае путь к файлу app/build/outputs/mapping/debug/mapping.txt. Далее необходимо воспользоваться либо скриптом retrace.sh из ANDROID_HOME/tools/proguard/bin, либо воспользоваться GUI утилитой ProguadGUI из ANDROID_HOME/tools/proguard/lib/proguardgui.jar. Воспользовавшись GUI утилитой мы получим следующую трассировку стека:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://andriydruk.github.io/img/Screen Shot 2015-08-04 at 23.34.25.png&#34; alt=&#34;Alt text&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Caused by: java.lang.RuntimeException: Stack deobfuscation example exception
    at com.druk.myapplication.MainActivity$CrashHelper.crash(Unknown Source)
    at com.druk.myapplication.MainActivity$CrashHelper.access$000(Unknown Source)
    at com.druk.myapplication.MainActivity.onCreate(Unknown Source)
    at android.app.Activity.performCreate(Activity.java:6162)
    at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1107)
    at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2370)
    at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2477)
    at android.app.ActivityThread.-wrap11(ActivityThread.java)
    at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1345)
    at android.os.Handler.dispatchMessage(Handler.java:102)
    at android.os.Looper.loop(Looper.java:148)
    at android.app.ActivityThread.main(ActivityThread.java:5415)
    at java.lang.reflect.Method.invoke(Native Method)
    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:725)
    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:615)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Хорошо когда в методе у нас всего одна строка, но на практике такое встречается редко. Поэтому неплохо было бы получить номер строки вместо Unknown Source. Согласно &lt;a href=&#34;http://proguard.sourceforge.net/manual/examples.html#stacktrace&#34;&gt;официальной документации&lt;/a&gt; для этого нужно в файл настроек proguard добавить&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;-printmapping out.map
-renamesourcefileattribute SourceFile
-keepattributes SourceFile,LineNumberTable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Первая строка в нашем случае не нужна, потому что она включена в Android проектах по умолчанию. Третья строка включает сохранение имен исходных файлов и таблицы номеров строк (что мы и хотели получить). Но стоит обратить внимание на вторую строку. Это правило переименовывает все имена исходных файлов в  &amp;ldquo;SourceFile&amp;rdquo;, что является весьма важным в обфускации таких языков как Java, где зачастую Class name == Source file name. Также это возволяет не выдать внутрених классов, так как после обфускации связь между внутреним и внешним классами обычно разрывается.&lt;/p&gt;

&lt;p&gt;В итоге после добавления новых правил мы получим следующую трассировку стека:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Caused by: java.lang.RuntimeException: Stack deobfuscation example exception
    at com.druk.myapplication.a.b(SourceFile:42)
    at com.druk.myapplication.a.a(SourceFile:40)
    at com.druk.myapplication.MainActivity.onCreate(SourceFile:15)
    at android.app.Activity.performCreate(Activity.java:6162)
    at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1107)
    at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2370)
    at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2477)
    at android.app.ActivityThread.-wrap11(ActivityThread.java)
    at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1345)
    at android.os.Handler.dispatchMessage(Handler.java:102)
    at android.os.Looper.loop(Looper.java:148)
    at android.app.ActivityThread.main(ActivityThread.java:5415)
    at java.lang.reflect.Method.invoke(Native Method)
    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:725)
    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:615)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;И после деобфускации:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Caused by: java.lang.RuntimeException: Stack deobfuscation example exception
    at com.druk.myapplication.MainActivity$CrashHelper.crash(SourceFile:42)
    at com.druk.myapplication.MainActivity$CrashHelper.access$000(SourceFile:40)
    at com.druk.myapplication.MainActivity.onCreate(SourceFile:15)
    at android.app.Activity.performCreate(Activity.java:6162)
    at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1107)
    at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2370)
    at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2477)
    at android.app.ActivityThread.-wrap11(ActivityThread.java)
    at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1345)
    at android.os.Handler.dispatchMessage(Handler.java:102)
    at android.os.Looper.loop(Looper.java:148)
    at android.app.ActivityThread.main(ActivityThread.java:5415)
    at java.lang.reflect.Method.invoke(Native Method)
    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:725)
    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:615)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Подведем итог: залог успешной поддержки обфусцированного приложения это сохранения всех mapping файлов для всех выпущенных сборок. Хорошой практикой есть построение сборок на CI сервере с сохрарнением apk файлов и mapping файлов с тегами соотвествующих сборок (например 4 первых символа hash коммита). В таком случае если вы знаете с какой сборки былa получена трассировка стека, вы будете знать где искать соответсующий mapping файл. Также возможно стоит посмотреть в сторону сторонних сервисов сбора информации о аварийных ситуациях. Например, такие сервисы как Crashlytics деобфусцируют трасировки стеков на стороне сервера, что весьма удобно и не требует никаких дополнительных действий со стороны разработчика. Но вы должны четко понимать что при каждом построении сборки ваши mapping файлы будут отправляться на сервера Crashlytics. Что может быть не безопасно, ведь человек завладевший этими файлами не будет имееть никаких ограничений по деобфускации всего исходного кода вашего приложения.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Что такое .aar библиотеки?</title>
      <link>http://andriydruk.github.io/post/what_is_aars/</link>
      <pubDate>Wed, 15 Jul 2015 21:39:00 +0300</pubDate>
      
      <guid>http://andriydruk.github.io/post/what_is_aars/</guid>
      <description>

&lt;p&gt;Уже прошло больше года с анонса Android &lt;a href=&#34;http://tools.android.com/tech-docs/new-build-system&#34;&gt;New Build System&lt;/a&gt;, работа над которой кипит и по сей день: в экспериментальной области все еще находится несколько увлекательных возможностей &lt;a href=&#34;http://tools.android.com/tech-docs/jackandjill&#34;&gt;Jack and Jill Tool Chain&lt;/a&gt; и &lt;a href=&#34;http://tools.android.com/tech-docs/new-build-system/gradle-experimental#TOC-Ndk-Integration&#34;&gt;NDK Integration&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Но одной из самых ожидаемых возможностей новой системы сборки стала поддержка aar бибилотек - нового бинарного формата бибилотек, который в отличии от jar бибилотек может содержать android ресурсы (res, assets, native libraries, etc).  В это статье я хотел поделиться своим опытом работы с aar бибилиотеками.&lt;/p&gt;

&lt;h2 id=&#34;1-что-такое-aar-бибилотеки:2d39079d7dbc3e98619f859c896fcc85&#34;&gt;1. Что такое .aar бибилотеки?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://tools.android.com/tech-docs/new-build-system/aar-format&#34;&gt;Официальная документация&lt;/a&gt; говорит о том что aar  - это бинарный дистрибутив Android Library Project и прдеставляет собой zip файл с расширением .aar, котороый содержит:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;/AndroidManifest.xml (mandatory)&lt;/li&gt;
&lt;li&gt;/classes.jar (mandatory)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;/res/ (mandatory)&lt;/li&gt;
&lt;li&gt;/R.txt (mandatory)&lt;/li&gt;
&lt;li&gt;/assets/ (optional)&lt;/li&gt;
&lt;li&gt;/libs/*.jar (optional)&lt;/li&gt;
&lt;li&gt;/jni/&lt;abi&gt;/*.so (optional)&lt;/li&gt;
&lt;li&gt;/proguard.txt (optional)&lt;/li&gt;
&lt;li&gt;/lint.jar (optional)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Разберем подробней. AndroidManifest.xml это оригинальный манифест с вашей библиотеки. Файл сlasses.jar содержит скомпилированные java классы библиотеки (они будут слиты с остальными во время компиляции основного проекта). Исходя из документации R.txt это выходной файл aapt (Android Asset Packaging Tool) с флагом &amp;ndash;output-text-symbols, тоесть это часть вашего R.java который будет слит с остальными результатами работы aapt при сборке основного проекта. Далее идут директории assets, res, libs и jni, которые содержат оригинальные файлы из каталога src вашей бибилотеки (часть содержимого каталога res может быть удаленно после выполнения обфускации). Файл proguard.txt копируется из вашей root директории библиотеки для того чтобы передать правила обфускации в основной проект. При  работе с .aar стоит учитывать что если флаг minifyEnabled в build.gradle файле вашей библиотеки установлен в true, то при сборке она будет обфусцирована. Также aar бибилитека может содержать пользовательские lint правила в &lt;a href=&#34;https://groups.google.com/forum/#!msg/adt-dev/seWAK5r1fjI/0ed2rztjDbEJ&#34;&gt;lint.jar&lt;/a&gt;, они будут распостраняться и на основной проект.&lt;/p&gt;

&lt;h2 id=&#34;2-как-посторить-aar-библиотеку:2d39079d7dbc3e98619f859c896fcc85&#34;&gt;2. Как посторить .aar библиотеку?&lt;/h2&gt;

&lt;p&gt;Для того чтобы построить aar бибилотеку достаточно выполнить ./grdlew assemble в корне вашего проекта. Эта команда соберет все flavour и buildTypes. Но по причине ограничений gradle по умолчанию приложениями будет использоваться всегда defaultRelease сборка вашей aar бибилотеки. Если вы хотите поменять default конфигурацию, это можно сделать так&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;android {
    defaultPublishConfig &amp;quot;debug&amp;quot;
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;или так:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;android {
    defaultPublishConfig &amp;quot;flavor1Debug&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В первом случае в качестве default конфигурации используется debug build, во втором debug build варианта flavor1. Кроме того вы можете включить публикацию всех конфигураций:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;android {        
    publishNonDefault true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-как-подключить-aar-бибилиотеку:2d39079d7dbc3e98619f859c896fcc85&#34;&gt;3. Как подключить .aar бибилиотеку?&lt;/h2&gt;

&lt;p&gt;Существует 4 способа подключения aar библиотек:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Подключение в качестве модуля&lt;/li&gt;
&lt;li&gt;Плоский репозиторий (Flat directory)&lt;/li&gt;
&lt;li&gt;Локальный репозиторий (Local maven repo)&lt;/li&gt;
&lt;li&gt;Удаленный репозиторий (Remote maven repo)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;3-1-подключение-модуля:2d39079d7dbc3e98619f859c896fcc85&#34;&gt;3.1 Подключение модуля&lt;/h3&gt;

&lt;p&gt;Это пожалуй самый простой способ и с ним знакомо большинство Android разработчиков. Вы можете импортировать библиотеку как модуль в ваш проект и установить зависимость в своем основном проекте следующим образом:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;dependencies {
    compile project(&#39;:your_library_module_name&#39;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Также вы можете установить &lt;a href=&#34;http://tools.android.com/tech-docs/new-build-system/user-guide#TOC-Referencing-a-Library&#34;&gt;зависимость на определную конфигурацию вашей библотеки&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;dependencies {
    flavor1Compile project(path: &#39;:your_library_module_name&#39;, configuration: &#39;flavor1Release&#39;)
    flavor2Compile project(path: &#39;:your_library_module_name&#39;, configuration: &#39;flavor2Release&#39;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Такой подход позволяет вам легко вносить изменения в код вашей библиотеки и тут же получать aar при перекомпиляции. По большому счету вам даже не стоит задумывать о том что aar файл строится при сборке вашего проекта, в данном случае он выступает лишь в роли промежуточного звена сборки. Дальше мы расмотрим подходы подлючения собраных aar файлов.&lt;/p&gt;

&lt;h3 id=&#34;3-1-плоский-репозиторий:2d39079d7dbc3e98619f859c896fcc85&#34;&gt;3.1 Плоский репозиторий&lt;/h3&gt;

&lt;p&gt;Самый простой способ подключения aar бибилотек в собраном виде это простое копирование в директорию проекта. Для того чтобы установить зависимость на такой файл нужно включить директорию в список своих репозиториев в build.gradle&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;repositories {
    flatDir {
        dirs &#39;path_to_folder_with_aar&#39;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;После этого можно подключать библиотеку:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;dependencies {
   compile &#39;com.example:library:1.0.0@aar&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Версия бибилиотеки и namespace в данном случая ни на что не влияют, так как flatDir репозитории их просто игнорируют.&lt;/p&gt;

&lt;h3 id=&#34;3-2-локальный-репозиторий:2d39079d7dbc3e98619f859c896fcc85&#34;&gt;3.2 Локальный репозиторий&lt;/h3&gt;

&lt;p&gt;Для использования такого подхода вам нужен maven репозиторий разположений локально на вашем компьютере. Существует множество готовых gradle плагинов для публикации aar бибилиотек, но мы воспользуемся консольной устилитой mvn. Для начала следует проверить наличие установленого &lt;a href=&#34;https://maven.apache.org/&#34;&gt;maven&lt;/a&gt; в вашей системе.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-zsh&#34;&gt;mvn --version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Если он отсутвует, его следует установить. Для публикации артефакта (в нашем случае .aar  библиотеки) в репозиторий используйте команду:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-zsh&#34;&gt;mvn install:install-file -Dfile=&amp;lt;path_to_your_aar&amp;gt; -DgroupId=&amp;lt;domain&amp;gt; -DartifactId=&amp;lt;artifact_id&amp;gt; -Dversion=&amp;lt;version&amp;gt; -Dpackaging=aar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Например:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-zsh&#34;&gt;mvn install:install-file -Dfile=mDNSShared-release.aar -DgroupId=com.dnssd -DartifactId=mDNSShared -Dversion=1.0.0 -Dpackaging=aar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;На самом деле команда mvn install выполнит копирование вашего aar файла в директорию локального репозитория и сгенерирует соотвествующий pom.xml файл. Перейдем в ~/.m2/repository директорию на вашем компьютере. После выполнения команды install в этой директории должны появится поддиректории вашего домена, в случае моего приемера это&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-zsh&#34;&gt;~/.m2/repository/com/dnssd/mDNSShared/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В это каталоге располгаются все версии вашего aar артефакта (под этим термином подразумевается любой бинарный файл помещеный в maven репозиторий). В моем случае это директория 1.0.0 в которой содержится 3 файла: _remote.repositories, mDNSShared-1.0.1.aar, mDNSShared-1.0.1.pom. Теперь подключим бибилотеку из локального репозитория. Прежде всего нужно добавить локальный maven репозиторий в список доступных:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;repositories {
    mavenLocal()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;После этого можно устанавливать зависимости с помощью ключего слова compile также как мы это делает с flatDir&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;dependencies {
    compile &#39;com.dnnsd:mDNSShared:1.0.0&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Именно такой подход распотсранения aar использован в Android Support Libraries. Все локальные maven репозитории разпаковуются и обновляются вместе с sdk.  Можете заглянуть в директории ANDROID_HOME/extras/android/m2repository или ANDROID_HOME/extras/google/m2repository.&lt;/p&gt;

&lt;h3 id=&#34;3-3-удаленный-репозиторий:2d39079d7dbc3e98619f859c896fcc85&#34;&gt;3.3 Удаленный репозиторий&lt;/h3&gt;

&lt;p&gt;Подход с использвованием удаленного репозитория ничем не отличается от локального за исключением необходимости указания ссылки на репозиторий. Gradle соддержит ссылки на Maven Central и JCenter репозитории. Кроме этого gradle позволяет указывать прямой url на сервер maven репозитория:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;repositories {
    mavenCentral()
    jCenter()
    maven { url &#39;https://maven.fabric.io/repo&#39; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Установка зависимостей аналогична предыдущим способам:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;dependencies {
    compile(&#39;com.crashlytics.sdk.android:crashlytics:2.2.4@aar&#39;) {
        transitive = true;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Вот и все.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Добро пожаловать</title>
      <link>http://andriydruk.github.io/post/welcome/</link>
      <pubDate>Tue, 07 Jul 2015 23:10:36 +0300</pubDate>
      
      <guid>http://andriydruk.github.io/post/welcome/</guid>
      <description>&lt;p&gt;Привет всем и добро пожаловать в еще один Android Developer Blog!&lt;/p&gt;

&lt;p&gt;Я долго вынашивал идею создания блога о разработке. Как полагается настоящему гику потратил немало времени на обзор существующих блогер платформ и статических генераторов сайтов, и вот наконец я добрался до написания статей. Но обо всем по порядку&amp;hellip;&lt;/p&gt;

&lt;p&gt;Сначала расскажу немного о себе. Основной род моей деятельности это разработка мобильных приложений. Еще со школы я увлекаюсь математикой и программированием, окончил магистратуру &lt;a href=&#34;http://www.kpi.kharkov.ua/en/&#34;&gt;Kharkiv Polytechnic Institute&lt;/a&gt; по специальности Software Engeneering. На данный момент я занимаю должность &lt;a href=&#34;https://www.linkedin.com/profile/view?id=156417157&#34;&gt;Android Team Lead&lt;/a&gt; в Харькове (Украина). Помимо разработки занимаюсь обучением студентов и управлением командой.&lt;/p&gt;

&lt;p&gt;Как вы можете знать мобильная разработка является на данный момент одним из самых перспективных направлений в индустрии. С моей точки зрения, это еще и одна из самых интересных областей. В своей профессиональной карьере мне приходится работать с проектами на разных мобильных платформах, но все же моя страсть это Android. Возможно вас заинтересуют некоторые мои инструменты, которые я публикую в &lt;a href=&#34;https://play.google.com/store/apps/developer?id=Andriy+Druk&#34;&gt;Google Play&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Android действительно удивительная система. После многих лет работы с ней я все еще наталкиваюсь на новые ее возможности, новые области применения, новые способы решения проблем. В этом блоге я хотел бы поделиться с вами некоторыми паттернами, обзором новых для меня технологий или же просто своими мыслями о индустрии.&lt;/p&gt;

&lt;p&gt;Я искренне надеюсь, что этот блог будет для вас источником полезной информации, и поможет вам в будущей разработке. И конечно же меня интересует ваши мнение, поэтому не стесняйтесь комментировать статьи. Буду рад конструктивной критике.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>