<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on Andriy Druk</title>
    <link>http://localhost:1313/categories/golang/</link>
    <description>Recent content in Golang on Andriy Druk</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Code released under the Apache 2.0 license.</copyright>
    <lastBuildDate>Sat, 05 Sep 2015 14:14:19 +0300</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/golang/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Bonjour in Android application</title>
      <link>http://localhost:1313/post/mdnsresponder/</link>
      <pubDate>Sat, 05 Sep 2015 14:14:19 +0300</pubDate>
      
      <guid>http://localhost:1313/post/mdnsresponder/</guid>
      <description>&lt;p&gt;&lt;strong&gt;What is Bonjour?&lt;/strong&gt;
That what say wiki about Bonjour&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Bonjour is Apple&amp;rsquo;s implementation of Zero-configuration networking (Zeroconf), a group of technologies that includes service discovery, address assignment, and hostname resolution. Bonjour locates devices such as printers, other computers, and the services that those devices offer on a local network using multicast Domain Name System (mDNS) service records.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Apple determinate this in another way:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Bonjour, also known as zero-configuration networking, enables automatic discovery of devices and services on a local network using industry standard IP protocols. Bonjour makes it easy to discover, publish, and resolve network services with a sophisticated, yet easy-to-use, programming interface that is accessible from Cocoa, Ruby, Python, and other languages.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In another words, is the software that used for discovering another devices (PC, Mac, smartphones, printers, etc) in network via all available interfaces. In terminologies of Bonjour this called &amp;ldquo;service&amp;rdquo;. Any process in operation system can register service and assign it to opened port on this computer (actually Bonjour not guarantee that port in service&amp;rsquo;s metadata actually opened and connected to process that registered this service) All services are registered in some domain (that&amp;rsquo;s mandatory parameter of all services and you can find domain naming conventions &lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/NetServices/Articles/domainnames.html&#34;&gt;here&lt;/a&gt;). Also applications can discover all available services in network(s) at any domain. You should understand that Bonjour is technology only for discovering, all connection stuff you should do by yourself anyway.&lt;/p&gt;

&lt;p&gt;You can find more information about Bonjour in &lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/NetServices/Introduction.html&#34;&gt;official documentation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What about Android? Can we use this powerful technology in our Android project?&lt;/strong&gt; Yes. Google use this technology with a lot of their projects. For example: you try to connect to Chromecast in your living room: it&amp;rsquo;s Bonjour. You play some games with friends via wifi: it&amp;rsquo;s Bonjour. You print some documents via wifi: it&amp;rsquo;s Bonjour (in most case).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;There is any standard API for it?&lt;/strong&gt; Yes. Google provide &lt;a href=&#34;http://developer.android.com/training/connect-devices-wirelessly/nsd.html&#34;&gt;Network Service Discovery API&lt;/a&gt; that use the same technology that Apple use in Mac OS X and iOS (Oh, I forget to tell you that Bonjour is open-sourced). This API are  available from API level 16 (Android 4.1) and work in general good, but it not covered all Bonjour API. One of the most important part of Bonjour is ability to share some metainformation, also known as TXT records.&lt;/p&gt;

&lt;p&gt;That what &lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/NetServices/Articles/NetServicesArchitecture.html&#34;&gt;official documentation&lt;/a&gt; say about it:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The TXT record has the same name as the corresponding SRV record, and can contain a small amount of additional information about the service instance, typically no more than 100â€“200 bytes at most. This record may also be empty. For example, a network game could advertise the name of the map being used in a multiplayer game, and a chat program could advertise the availability of the user (for example, idle, away, or available). If you need to transmit larger amounts of data, the host should establish a connection with the client and send the data directly.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It can be very useful and I can&amp;rsquo;t understand why this feature are not available in official SDK, because there are no technical reason for it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;If there are any other options?&lt;/strong&gt; Yes, another option for Android developer is &lt;a href=&#34;http://jmdns.sourceforge.net&#34;&gt;jmDNS&lt;/a&gt; library. It&amp;rsquo;s open-source library written on Java 1.6 (because for Android developers it&amp;rsquo;s matter) and is compatible with Apple&amp;rsquo;s Bonjour. You can use it at any Android API level and this library supports TXT records. But I have some issue with this library (I got few crashes inside thsis library from Crashlytcics, and I don&amp;rsquo;t have any ideas how I can fix it) and it work pretty slow.&lt;/p&gt;

&lt;p&gt;Also Google (not Android open source) present new cross platform library &lt;a href=&#34;https://developers.google.com/nearby/&#34;&gt;Google Nearby API&lt;/a&gt;. This API contents two conceptual different API: Nearby Messages API and the Nearby Connections API. Message API can be used for discovering services via all available interfaces (Wifi, Wifi-direct, Bluetooth 2.0 and LE) and connect two or more devices via Internet. Actually it&amp;rsquo;s very interesting idea in time of fast mobile internet (Maybe I will write about it more in another article). And Connections API can be used for discovering and connection via wifi interface. Actually it&amp;rsquo;s really good solution. You shouldn&amp;rsquo;t care about sockets, ports, discovering, connections and multithreading. All this code has already written for you. But this solution work only with Android and iOS, and it&amp;rsquo;s not open-source (that&amp;rsquo;s why I pay attention about Google above). If you want discover some services from another system or that work with another libraries (for example: printers or vnc servers) you should look to another options.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Do you have any idea?&lt;/strong&gt; Yes, and it why I write this article. I have good news for you: you can just get Apple implementation of Bonjour and use it in your Android project.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WHAAAAAAT? Apple libraries at Android project?&lt;/strong&gt; Yes, it called mDnsResponder and it was written at C many years ago (actually Apple bought it). Look at architecture overview from [documentation]():&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A typical mDNS program contains three components:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;+------------------+
|   Application    |
+------------------+
|    mDNS Core     |
+------------------+
| Platform Support |
+------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The &amp;ldquo;mDNS Core&amp;rdquo; layer is absolutely identical for all applications and
all Operating Systems.&lt;/p&gt;

&lt;p&gt;The &amp;ldquo;Platform Support&amp;rdquo; layer provides the necessary supporting routines
that are specific to each platform &amp;ndash; what routine do you call to send
a UDP packet, what routine do you call to join multicast group, etc.&lt;/p&gt;

&lt;p&gt;The &amp;ldquo;Application&amp;rdquo; layer does whatever that particular application wants
to do. It calls routines provided by the &amp;ldquo;mDNS Core&amp;rdquo; layer to perform
the functions it needs &amp;ndash;
 * advertise services,
 * browse for named instances of a particular type of service
 * resolve a named instance to a specific IP address and port number,
 * etc.
The &amp;ldquo;mDNS Core&amp;rdquo; layer in turn calls through to the &amp;ldquo;Platform Support&amp;rdquo;
layer to send and receive the multicast UDP packets to do the actual work.&lt;/p&gt;

&lt;p&gt;Apple currently provides &amp;ldquo;Platform Support&amp;rdquo; layers for Mac OS 9, Mac OS X,
Microsoft Windows, VxWorks, and for POSIX platforms like Linux, Solaris,
FreeBSD, etc.&lt;/p&gt;

&lt;p&gt;Note: Developers writing applications for OS X do not need to incorporate
this code into their applications, since OS X provides a system service to
handle this for them. If every application developer were to link-in the
mDNSResponder code into their application, then we would end up with a
situation like the picture below:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+    +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+    +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+
  |   Application 1  |    |   Application 2  |    |   Application 3  |
  +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+    +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+    +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+
  |    mDNS Core     |    |    mDNS Core     |    |    mDNS Core     |
  +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+    +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+    +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+
  | Platform Support |    | Platform Support |    | Platform Support |
  +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+    +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+    +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This would not be very efficient. Each separate application would be sending
their own separate multicast UDP packets and maintaining their own list of
answers. Because of this, OS X provides a common system service which client
software should access through the &amp;ldquo;/usr/include/dns_sd.h&amp;rdquo; APIs.&lt;/p&gt;

&lt;p&gt;The situation on OS X looks more like the picture below:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;                               -------------------
                              /                   \
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;+&amp;mdash;&amp;mdash;&amp;mdash;+    +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+    +&amp;mdash;&amp;mdash;&amp;mdash;+   \  +&amp;mdash;&amp;mdash;&amp;mdash;+
  |  App 1  |&amp;lt;&amp;ndash;&amp;gt;|    daemon.c      |&amp;lt;&amp;ndash;&amp;gt;|  App 2  |    -&amp;gt;|  App 3  |
  +&amp;mdash;&amp;mdash;&amp;mdash;+    +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+    +&amp;mdash;&amp;mdash;&amp;mdash;+      +&amp;mdash;&amp;mdash;&amp;mdash;+
                 |    mDNS Core     |
                 +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+
                 | Platform Support |
                 +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Applications on OS X make calls to the single mDNSResponder daemon
which implements the mDNS and DNS-SD protocols.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Actually Android use the same solution with one system daemon and lots of applications. This daemon available for developers since API 16 (Android 4.1) and you can connect from native level via dns-sd.h.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;But I don&amp;rsquo;t know C/C++, do you have any Java wrapper for it?&lt;/strong&gt; No, but Apple has. Let&amp;rsquo;s compile it together. First of all you should compile mDnsResponder native client and you can find it &lt;a href=&#34;https://android.googlesource.com/platform/external/mdnsresponder/&#34;&gt;here&lt;/a&gt;. It&amp;rsquo;s part of android open-source project and updated from time to time, but it completely independent library that work throw POSIX API. I believe, that you can use any version of it with any version of Android. Also you should add JNI bridge to this native source code. Just go to dns-sd.h file and look for version of mDNSResponer, in my case it was:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* _DNS_SD_H contains the mDNSResponder version number for this header file, formatted as follows:
 *   Major part of the build number * 10000 +
 *   minor part of the build number *   100
 * For example, Mac OS X 10.4.9 has mDNSResponder-108.4, which would be represented as
 * version 1080400. This allows C code to do simple greater-than and less-than comparisons:
 * e.g. an application that requires the DNSServiceGetProperty() call (new in mDNSResponder-126) can check:
 *
 *   #if _DNS_SD_H+0 &amp;gt;= 1260000
 *   ... some C code that calls DNSServiceGetProperty() ...
 *   #endif
 *
 * The version defined in this header file symbol allows for compile-time
 * checking, so that C code building with earlier versions of the header file
 * can avoid compile errors trying to use functions that aren&#39;t even defined
 * in those earlier versions. Similar checks may also be performed at run-time:
 *  =&amp;gt; weak linking -- to avoid link failures if run with an earlier
 *     version of the library that&#39;s missing some desired symbol, or
 *  =&amp;gt; DNSServiceGetProperty(DaemonVersion) -- to verify whether the running daemon
 *     (&amp;quot;system service&amp;quot; on Windows) meets some required minimum functionality level.
 */

#ifndef _DNS_SD_H
#define _DNS_SD_H 3201080
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It means that it&amp;rsquo;s mDNSResponder 320.10.80. Now go to &lt;a href=&#34;http://opensource.apple.com/tarballs/mDNSResponder/&#34;&gt;Apple Open Source&lt;/a&gt; site and find this version. Unzip archive and found folder /mDNSShared/Java/. Copy JNISupport.c file to you jni folder and all *.java files to your scr folder. After it add JNISupport to Android.mk file, in my case:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;LOCAL_SRC_FILES :=  mDNSShared/dnssd_clientlib.c  \
                    mDNSShared/dnssd_clientstub.c \
                    mDNSShared/dnssd_ipc.c \
                    mDNSShared/JNISupport.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s all: compile you native code via command &amp;lsquo;ndk-build&amp;rsquo; and compile Android project.&lt;/p&gt;

&lt;p&gt;And one more thing: Android can stop daemon for save battery live or any other reasons if it doesn&amp;rsquo;t used by any application. That&amp;rsquo;s why you should call next method before working with any code from com.apple.dnssd.*.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;context.getSystemService(Context.NSD_SERVICE);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Else mDNSResponder will throw checked exception &amp;ldquo;DNSD-SD Daemon not available&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Do you have any examples?&lt;/strong&gt; Yep, you can find example of using mDNSResponder with compiled native code in my project Bonjour Browser, all code available on &lt;a href=&#34;https://github.com/andriydruk/BonjourBrowser&#34;&gt;github&lt;/a&gt;. Also you can look on it in action on &lt;a href=&#34;https://play.google.com/store/apps/details?id=com.druk.bonjour.browser&amp;amp;hl=uk&#34;&gt;Google Play&lt;/a&gt;, it works really fast.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>